#!/usr/bin/env zsh
# Copyright (c) 2023 Sebastian Gniazdowski

# Recognize and save info on run as `#!/usr/bin/env zsh` script
[[ $0 != zscan || -n $ZSH_SCRIPT ]]&&integer bescript=1

# Set options
builtin emulate -L zsh -o extendedglob -o noshortloops \
            -o warncreateglobal -o typesetsilent

# $0 support
0=${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}

# Load initialization script
source "$0:h:h"/libexec/zs::global-init.zsh

# -v verbose
# -G no cd, absolute paths
# -s select visually
# -# offset of the picked °feature° when multiple match
# -l show files in the °feature°
local -A Opts
builtin zparseopts -D -E -A Opts -- v -C:||return 7

if (($+Opts[-h]||$+Opts[--help]));then
    local nl=$'\n'
    tigmsg %B{33}zscan%b -vGghl\# %B{41}\<°feature-ID°\>$nl\
    return 0
fi

# Automatic -C value
: ${Opts[-C]:=$PWD}

local WDIR=$Opts[-C]

if [[ ! -d $WDIR ]];then
    zsmsg -h {err}Error: The path {path}$WDIR{err} \
        isn\'t a directory
fi

# Establish text editor
util/zs::get-editor||return 1

local IN=$1 QED=$REPLY Q
if [[ ! -r $WDIR/$IN ]];then
    zsmsg -h {err}Error:{txt} input file \
        {quot}\"{file}$IN{quot}\"{txt} doesn\'t exist
    return 1
fi

util/zs::read-file $IN normal||return 1
local -a content=("$reply[@]")
integer RET

local -a funs=(${(on)functions[(I)checks/zs:<->:*]}) matcharr
for Q ($funs);do
    zsmsg -h {warn}Warning:%b running check: {func}${Q/[^\/]#\/zs:<->:}{warn}%b…
    repeat 1 {"$Q" content matcharr;RET=$?;}
    if ((RET));then
        if ! util/zs::get-txt "$RET";then
            zsmsg -h {err}Error:{txt}Couldn\'t found warning text of num. \
                {quot}\#{num}$RET
        else
            eval REPLY=\"$REPLY\"
            zsmsg -h $(REPLY="$REPLY";print -- $REPLY)
        fi
    fi
done